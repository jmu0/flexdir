!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADD	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
CHECKER_H	checker.h	2;"	d
COPIES	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
Checker	checker.cpp	/^Checker::Checker(Worker * w)$/;"	f	class:Checker
Checker	checker.h	/^class Checker$/;"	c
DEF_LOGFILE	worker.cpp	18;"	d	file:
DELETE	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
EVENT_BUF_LEN	watcher.cpp	12;"	d	file:
EVENT_SIZE	watcher.cpp	11;"	d	file:
FLEXFILE	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
ID	worker.h	/^    taskID_t ID;$/;"	m	struct:task_t
MAX_LOAD_AVG	worker.cpp	19;"	d	file:
MAX_LOAD_SLEEP	worker.cpp	20;"	d	file:
MAX_WORKER_THREADS	worker.cpp	21;"	d	file:
NEW	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
NONE	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
ORPHAN	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
PRIMARY	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
REMOVE	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
RENAME	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
SECONDARY	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
SETTINGS	worker.cpp	17;"	d	file:
SYNC	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
VERBOSE	worker.cpp	22;"	d	file:
WATCHER_H	watcher.h	2;"	d
WORKER_H	worker.h	2;"	d
Watcher	watcher.cpp	/^Watcher::Watcher(Worker * w)$/;"	f	class:Watcher
Watcher	watcher.h	/^class Watcher$/;"	c
Worker	worker.cpp	/^Worker::Worker()$/;"	f	class:Worker
Worker	worker.h	/^class Worker$/;"	c
actionChangeLink	worker.cpp	/^int Worker::actionChangeLink(char * link, char * newTarget)$/;"	f	class:Worker
actionCopyFile	worker.cpp	/^int Worker::actionCopyFile(char * from, char * to)\/\/TODO: use rsync$/;"	f	class:Worker
actionCreateLink	worker.cpp	/^int Worker::actionCreateLink(char * target, char * linkname)$/;"	f	class:Worker
actionCreatedir	worker.cpp	/^int Worker::actionCreatedir(char * path)$/;"	f	class:Worker
actionDeleteFile	worker.cpp	/^int Worker::actionDeleteFile(char * path)$/;"	f	class:Worker
actionMoveFile	worker.cpp	/^int Worker::actionMoveFile(char * from, char * to)$/;"	f	class:Worker
actionSyncFile	worker.cpp	/^int Worker::actionSyncFile(char * from, char * to)$/;"	f	class:Worker
actualCopies	worker.h	/^    int actualCopies;$/;"	m	struct:flexfile_t
addTask	worker.cpp	/^    int Worker::addTask(taskID_t ID, string from, string to)$/;"	f	class:Worker
checkerThread	main.cpp	/^void * checkerThread(void * id)$/;"	f
condition	testWorker.cpp	/^pthread_cond_t condition = PTHREAD_COND_INITIALIZER;$/;"	v
copies	worker.h	/^    int copies;$/;"	m	struct:flexdir_t
doTask	worker.cpp	/^    int Worker::doTask(task_t * task)$/;"	f	class:Worker
fileTest	testWorker.cpp	/^void fileTest()$/;"	f
files	worker.h	/^    vector<flexfile_t> files;$/;"	m	struct:flexdir_t
files	worker.h	/^    vector<poolfile_t> files;$/;"	m	struct:pooldir_t
flexdir_t	worker.h	/^struct flexdir_t$/;"	s
flexdirs	worker.h	/^    vector<flexdir_t> flexdirs;$/;"	m	struct:settings_t
flexfile_t	worker.h	/^struct flexfile_t$/;"	s
freeMB	worker.h	/^    long freeMB;$/;"	m	struct:pooldir_t
from	worker.h	/^    string from;$/;"	m	struct:task_t
getFileExists	worker.cpp	/^bool Worker::getFileExists(const char * path)$/;"	f	class:Worker
getFlexStructFromPath	worker.cpp	/^int Worker::getFlexStructFromPath(flexdir_t * flexdir, flexfile_t * flexfile, string path)$/;"	f	class:Worker
getIsLink	worker.cpp	/^bool Worker::getIsLink(char * path)$/;"	f	class:Worker
getLinkTarget	worker.cpp	/^string Worker::getLinkTarget(char * path)$/;"	f	class:Worker
getLoadAverage	worker.cpp	/^double Worker::getLoadAverage()$/;"	f	class:Worker
getNdirs	worker.cpp	/^vector<pooldir_t> Worker::getNdirs(int n)$/;"	f	class:Worker
getPoolSizes	worker.cpp	/^void Worker::getPoolSizes()$/;"	f	class:Worker
getPoolStructFromPath	worker.cpp	/^int Worker::getPoolStructFromPath(pooldir_t * pooldir, poolfile_t * poolfile, string path)$/;"	f	class:Worker
getSettings	worker.cpp	/^settings_t * Worker::getSettings()$/;"	f	class:Worker
getTime	worker.cpp	/^string Worker::getTime(const char * format)$/;"	f	class:Worker
linktst	testWorker.cpp	/^void linktst(string testlink)$/;"	f
loadFileStructure	worker.cpp	/^void Worker::loadFileStructure()$/;"	f	class:Worker
loadSettings	worker.cpp	/^void Worker::loadSettings()$/;"	f	class:Worker
logFile	worker.h	/^        string logFile;$/;"	m	class:Worker
main	main.cpp	/^int main()$/;"	f
main	makefile	/^main = testWorker$/;"	m
main	testWorker.cpp	/^int main()$/;"	f
maxLoadAverage	worker.h	/^    double maxLoadAverage;$/;"	m	struct:settings_t
maxLoadSleep	worker.h	/^    int maxLoadSleep;$/;"	m	struct:settings_t
maxWorkerThreads	worker.h	/^    int maxWorkerThreads;$/;"	m	struct:settings_t
mutex	testWorker.cpp	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
naam	makefile	/^naam = flexdir$/;"	m
name	worker.h	/^    string name;$/;"	m	struct:flexfile_t
name	worker.h	/^    string name;$/;"	m	struct:poolfile_t
ndirtest	testWorker.cpp	/^void ndirtest()$/;"	f
p_path	worker.h	/^    string p_path;$/;"	m	struct:poolfile_t
path	worker.h	/^    string path;$/;"	m	struct:flexdir_t
path	worker.h	/^    string path;$/;"	m	struct:pooldir_t
pooldirSort	worker.cpp	/^bool pooldirSort(pooldir_t d1, pooldir_t d2)$/;"	f
pooldir_t	worker.h	/^struct pooldir_t$/;"	s
pooldirs	worker.h	/^    vector<pooldir_t> pooldirs;$/;"	m	struct:settings_t
poolfile_t	worker.h	/^struct poolfile_t$/;"	s
printFileStructure	worker.cpp	/^void Worker::printFileStructure()$/;"	f	class:Worker
printSettings	worker.cpp	/^void Worker::printSettings()$/;"	f	class:Worker
role	worker.h	/^    role_t role;$/;"	m	struct:flexfile_t
role	worker.h	/^    role_t role;$/;"	m	struct:poolfile_t
role_t	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	g
s	testWorker.cpp	/^settings_t * s;$/;"	v
settings	worker.h	/^        settings_t settings;$/;"	m	class:Worker
settingsValidLine	worker.cpp	/^bool Worker::settingsValidLine(const string &line) const$/;"	f	class:Worker
settings_t	worker.h	/^struct settings_t $/;"	s
sizeMB	worker.h	/^    long sizeMB;$/;"	m	struct:pooldir_t
start	checker.cpp	/^void Checker::start()$/;"	f	class:Checker
start	watcher.cpp	/^void Watcher::start()$/;"	f	class:Watcher
startDaemon	main.cpp	/^void startDaemon()$/;"	f
startThreads	main.cpp	/^void startThreads()$/;"	f
startThreads	testWorker.cpp	/^void startThreads()$/;"	f
startWorker	worker.cpp	/^void Worker::startWorker(pthread_mutex_t * mutex, pthread_cond_t * condition)$/;"	f	class:Worker
symlinkTest	testWorker.cpp	/^void symlinkTest(){$/;"	f
taskID_t	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	g
task_t	worker.h	/^struct task_t$/;"	s
tasks	worker.h	/^    queue<task_t> tasks;$/;"	m	struct:settings_t
testFunctions	testWorker.cpp	/^void testFunctions()$/;"	f
testTasks	testWorker.cpp	/^void testTasks()$/;"	f
to	worker.h	/^    string to;$/;"	m	struct:task_t
usedPerc	worker.h	/^    double usedPerc;$/;"	m	struct:pooldir_t
verbose	worker.h	/^    bool verbose;$/;"	m	struct:settings_t
w	main.cpp	/^Checker ch(&w);$/;"	v
w	main.cpp	/^Watcher wa(&w);$/;"	v
w	main.cpp	/^Worker w;$/;"	v
wThread	testWorker.cpp	/^void * wThread(void * id)$/;"	f
watchdescriptor	worker.h	/^    int watchdescriptor;$/;"	m	struct:flexdir_t
watcherThread	main.cpp	/^void * watcherThread(void * id)$/;"	f
worker	checker.h	/^        Worker * worker;$/;"	m	class:Checker
worker	watcher.h	/^        Worker * worker;$/;"	m	class:Watcher
working	worker.h	/^        bool working;$/;"	m	class:Worker
writeLog	worker.cpp	/^void Worker::writeLog(string txt)$/;"	f	class:Worker
x_path	worker.h	/^    string x_path;$/;"	m	struct:flexfile_t
x_path	worker.h	/^    string x_path;$/;"	m	struct:poolfile_t
~Checker	checker.cpp	/^Checker::~Checker()$/;"	f	class:Checker
~Watcher	watcher.cpp	/^Watcher::~Watcher()$/;"	f	class:Watcher
~Worker	worker.cpp	/^Worker::~Worker()$/;"	f	class:Worker
