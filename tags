!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
ADD	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
CHECKER_H	checker.h	2;"	d
COPIES	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
Checker	checker.cpp	/^Checker::Checker(Worker * w)$/;"	f	class:Checker	signature:(Worker * w)
Checker	checker.h	/^        Checker(Worker * w);$/;"	p	class:Checker	access:public	signature:(Worker * w)
Checker	checker.h	/^class Checker$/;"	c
Checker::Checker	checker.cpp	/^Checker::Checker(Worker * w)$/;"	f	class:Checker	signature:(Worker * w)
Checker::Checker	checker.h	/^        Checker(Worker * w);$/;"	p	class:Checker	access:public	signature:(Worker * w)
Checker::start	checker.cpp	/^void Checker::start()$/;"	f	class:Checker	signature:()
Checker::start	checker.h	/^        void start();$/;"	p	class:Checker	access:public	signature:()
Checker::worker	checker.h	/^        Worker * worker;$/;"	m	class:Checker	access:private
Checker::~Checker	checker.cpp	/^Checker::~Checker()$/;"	f	class:Checker	signature:()
Checker::~Checker	checker.h	/^        ~Checker();$/;"	p	class:Checker	access:public	signature:()
DEF_LOGFILE	worker.cpp	18;"	d	file:
DELETE	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
EVENT_BUF_LEN	watcher.cpp	12;"	d	file:
EVENT_SIZE	watcher.cpp	11;"	d	file:
FLEXFILE	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
ID	worker.h	/^    taskID_t ID;$/;"	m	struct:task_t	access:public
MAX_LOAD_AVG	worker.cpp	19;"	d	file:
MAX_LOAD_SLEEP	worker.cpp	20;"	d	file:
MAX_WORKER_THREADS	worker.cpp	21;"	d	file:
NEW	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
NONE	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
ORPHAN	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
PRIMARY	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
REMOVE	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
RENAME	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
SECONDARY	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	e	enum:role_t
SETTINGS	worker.cpp	17;"	d	file:
SYNC	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	e	enum:taskID_t
VERBOSE	worker.cpp	22;"	d	file:
WATCHER_H	watcher.h	2;"	d
WORKER_H	worker.h	2;"	d
Watcher	watcher.cpp	/^Watcher::Watcher(Worker * w)$/;"	f	class:Watcher	signature:(Worker * w)
Watcher	watcher.h	/^        Watcher(Worker * w);$/;"	p	class:Watcher	access:public	signature:(Worker * w)
Watcher	watcher.h	/^class Watcher$/;"	c
Watcher::Watcher	watcher.cpp	/^Watcher::Watcher(Worker * w)$/;"	f	class:Watcher	signature:(Worker * w)
Watcher::Watcher	watcher.h	/^        Watcher(Worker * w);$/;"	p	class:Watcher	access:public	signature:(Worker * w)
Watcher::start	watcher.cpp	/^void Watcher::start()$/;"	f	class:Watcher	signature:()
Watcher::start	watcher.h	/^        void start();$/;"	p	class:Watcher	access:public	signature:()
Watcher::worker	watcher.h	/^        Worker * worker;$/;"	m	class:Watcher	access:private
Watcher::~Watcher	watcher.cpp	/^Watcher::~Watcher()$/;"	f	class:Watcher	signature:()
Watcher::~Watcher	watcher.h	/^        ~Watcher();$/;"	p	class:Watcher	access:public	signature:()
Worker	worker.cpp	/^Worker::Worker()$/;"	f	class:Worker	signature:()
Worker	worker.h	/^        Worker();$/;"	p	class:Worker	access:public	signature:()
Worker	worker.h	/^class Worker$/;"	c
Worker::Worker	worker.cpp	/^Worker::Worker()$/;"	f	class:Worker	signature:()
Worker::Worker	worker.h	/^        Worker();$/;"	p	class:Worker	access:public	signature:()
Worker::actionChangeLink	worker.h	/^        int actionChangeLink(char * link, char * newTarget);$/;"	p	class:Worker	access:public	signature:(char * link, char * newTarget)
Worker::actionCopyFile	worker.h	/^        int actionCopyFile(char * from, char * to);$/;"	p	class:Worker	access:public	signature:(char * from, char * to)
Worker::actionCreateLink	worker.h	/^        int actionCreateLink(char * target, char * linkname);$/;"	p	class:Worker	access:public	signature:(char * target, char * linkname)
Worker::actionCreatedir	worker.h	/^        int actionCreatedir(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
Worker::actionDeleteFile	worker.h	/^        int actionDeleteFile(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
Worker::actionMoveFile	worker.h	/^        int actionMoveFile(char * from, char * to);$/;"	p	class:Worker	access:public	signature:(char * from, char * to)
Worker::actionSyncFile	worker.h	/^        int actionSyncFile(char * from, char * to);$/;"	p	class:Worker	access:public	signature:(char * from, char * to)
Worker::addTask	worker.h	/^        int addTask(taskID_t ID, string from, string to);$/;"	p	class:Worker	access:public	signature:(taskID_t ID, string from, string to)
Worker::doTask	worker.h	/^        int doTask(task_t * task);$/;"	p	class:Worker	access:public	signature:(task_t * task)
Worker::getFileExists	worker.h	/^        bool getFileExists(const char * path);$/;"	p	class:Worker	access:public	signature:(const char * path)
Worker::getFlexStructFromPath	worker.h	/^        int getFlexStructFromPath(flexdir_t * flexdir, flexfile_t * flexfile, string path);$/;"	p	class:Worker	access:public	signature:(flexdir_t * flexdir, flexfile_t * flexfile, string path)
Worker::getIsLink	worker.h	/^        bool getIsLink(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
Worker::getLinkTarget	worker.h	/^        string getLinkTarget(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
Worker::getLoadAverage	worker.cpp	/^double Worker::getLoadAverage()$/;"	f	class:Worker	signature:()
Worker::getLoadAverage	worker.h	/^        double getLoadAverage();$/;"	p	class:Worker	access:public	signature:()
Worker::getNdirs	worker.cpp	/^vector<pooldir_t> Worker::getNdirs(int n)$/;"	f	class:Worker	signature:(int n)
Worker::getNdirs	worker.h	/^        vector<pooldir_t> getNdirs(int n);$/;"	p	class:Worker	access:public	signature:(int n)
Worker::getPoolFiles	worker.cpp	/^vector<poolfile_t> Worker::getPoolFiles(flexfile_t * flexfile)$/;"	f	class:Worker	signature:(flexfile_t * flexfile)
Worker::getPoolFiles	worker.h	/^        vector<poolfile_t> getPoolFiles(flexfile_t * flexfile);$/;"	p	class:Worker	access:private	signature:(flexfile_t * flexfile)
Worker::getPoolSizes	worker.cpp	/^void Worker::getPoolSizes()$/;"	f	class:Worker	signature:()
Worker::getPoolSizes	worker.h	/^        void getPoolSizes();$/;"	p	class:Worker	access:private	signature:()
Worker::getPoolStructFromPath	worker.h	/^        int getPoolStructFromPath(pooldir_t * pooldir, poolfile_t * poolfile, string path);$/;"	p	class:Worker	access:public	signature:(pooldir_t * pooldir, poolfile_t * poolfile, string path)
Worker::getSettings	worker.cpp	/^settings_t * Worker::getSettings()$/;"	f	class:Worker	signature:()
Worker::getSettings	worker.h	/^        settings_t * getSettings();$/;"	p	class:Worker	access:public	signature:()
Worker::getTime	worker.cpp	/^string Worker::getTime(const char * format)$/;"	f	class:Worker	signature:(const char * format)
Worker::getTime	worker.h	/^        string getTime(const char * format);$/;"	p	class:Worker	access:public	signature:(const char * format)
Worker::loadFileStructure	worker.cpp	/^void Worker::loadFileStructure()$/;"	f	class:Worker	signature:()
Worker::loadFileStructure	worker.h	/^        void loadFileStructure();$/;"	p	class:Worker	access:private	signature:()
Worker::loadFlexFiles	worker.cpp	/^void Worker::loadFlexFiles()$/;"	f	class:Worker	signature:()
Worker::loadFlexFiles	worker.h	/^        void loadFlexFiles();$/;"	p	class:Worker	access:private	signature:()
Worker::loadPoolFiles	worker.cpp	/^void Worker::loadPoolFiles()$/;"	f	class:Worker	signature:()
Worker::loadPoolFiles	worker.h	/^        void loadPoolFiles();$/;"	p	class:Worker	access:private	signature:()
Worker::loadSettings	worker.cpp	/^void Worker::loadSettings()$/;"	f	class:Worker	signature:()
Worker::loadSettings	worker.h	/^        void loadSettings();$/;"	p	class:Worker	access:private	signature:()
Worker::logFile	worker.h	/^        string logFile;$/;"	m	class:Worker	access:private
Worker::printFileStructure	worker.cpp	/^void Worker::printFileStructure()$/;"	f	class:Worker	signature:()
Worker::printFileStructure	worker.h	/^        void printFileStructure();$/;"	p	class:Worker	access:public	signature:()
Worker::printSettings	worker.cpp	/^void Worker::printSettings()$/;"	f	class:Worker	signature:()
Worker::printSettings	worker.h	/^        void printSettings();$/;"	p	class:Worker	access:public	signature:()
Worker::settings	worker.h	/^        settings_t settings;$/;"	m	class:Worker	access:private
Worker::settingsValidLine	worker.cpp	/^bool Worker::settingsValidLine(const string &line) const$/;"	f	class:Worker	signature:(const string &line) const
Worker::settingsValidLine	worker.h	/^        bool settingsValidLine(const string &line) const;$/;"	p	class:Worker	access:private	signature:(const string &line) const
Worker::startWorker	worker.h	/^        void startWorker(pthread_mutex_t * mutex, pthread_cond_t * condition);$/;"	p	class:Worker	access:public	signature:(pthread_mutex_t * mutex, pthread_cond_t * condition)
Worker::working	worker.h	/^        bool working;$/;"	m	class:Worker	access:private
Worker::writeLog	worker.cpp	/^void Worker::writeLog(string txt)$/;"	f	class:Worker	signature:(string txt)
Worker::writeLog	worker.h	/^        void writeLog(string txt);$/;"	p	class:Worker	access:public	signature:(string txt)
Worker::~Worker	worker.cpp	/^Worker::~Worker()$/;"	f	class:Worker	signature:()
Worker::~Worker	worker.h	/^        ~Worker();$/;"	p	class:Worker	access:public	signature:()
actionChangeLink	worker.h	/^        int actionChangeLink(char * link, char * newTarget);$/;"	p	class:Worker	access:public	signature:(char * link, char * newTarget)
actionCopyFile	worker.h	/^        int actionCopyFile(char * from, char * to);$/;"	p	class:Worker	access:public	signature:(char * from, char * to)
actionCreateLink	worker.h	/^        int actionCreateLink(char * target, char * linkname);$/;"	p	class:Worker	access:public	signature:(char * target, char * linkname)
actionCreatedir	worker.h	/^        int actionCreatedir(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
actionDeleteFile	worker.h	/^        int actionDeleteFile(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
actionMoveFile	worker.h	/^        int actionMoveFile(char * from, char * to);$/;"	p	class:Worker	access:public	signature:(char * from, char * to)
actionSyncFile	worker.h	/^        int actionSyncFile(char * from, char * to);$/;"	p	class:Worker	access:public	signature:(char * from, char * to)
actualCopies	worker.h	/^    int actualCopies;$/;"	m	struct:flexfile_t	access:public
addTask	testWorker.cpp	/^            w.addTask(DELETE, t.from, " ");$/;"	p	file:	signature:(DELETE, t.from, Ó)
addTask	testWorker.cpp	/^            w.addTask(DELETE, t.to, " ");$/;"	p	file:	signature:(DELETE, t.to, Ó)
addTask	testWorker.cpp	/^            w.addTask(t.ID, t.from, t.to);$/;"	p	file:	signature:(t.ID, t.from, t.to)
addTask	testWorker.cpp	/^    w.addTask(ADD, "\/home\/jos\/tmp\/addTest.txt", " ");$/;"	p	file:	signature:(ADD, Ó, Ó)
addTask	testWorker.cpp	/^    w.addTask(REMOVE, "\/home\/jos\/pool1\/home\/jos\/tmp\/removeTest.txt", " ");$/;"	p	file:	signature:(REMOVE, Ó, Ó)
addTask	worker.h	/^        int addTask(taskID_t ID, string from, string to);$/;"	p	class:Worker	access:public	signature:(taskID_t ID, string from, string to)
bl	worker.cpp	/^            long bl = buffer.f_blocks;$/;"	l
bs	worker.cpp	/^            long bs = buffer.f_bsize;$/;"	l
buffer	testWorker.cpp	/^    string buffer;$/;"	l
buffer	watcher.cpp	/^    char buffer[EVENT_BUF_LEN];$/;"	l
buffer	worker.cpp	/^    char buffer [80];$/;"	l
buffer	worker.cpp	/^    struct statvfs buffer;$/;"	l
checkerThread	main.cpp	/^void * checkerThread(void * id)$/;"	f	signature:(void * id)
checkerThread	main.cpp	/^void * checkerThread(void * id);$/;"	p	file:	signature:(void * id)
close	worker.cpp	/^        file.close();$/;"	p	file:	signature:()
close	worker.cpp	/^    la.close();$/;"	p	file:	signature:()
close	worker.cpp	/^    log.close();$/;"	p	file:	signature:()
condition	testWorker.cpp	/^pthread_cond_t condition = PTHREAD_COND_INITIALIZER;$/;"	v
copies	worker.h	/^    int copies;$/;"	m	struct:flexdir_t	access:public
ct	main.cpp	/^    pthread_t wt, ct;$/;"	l
dir	worker.cpp	/^                DIR* dir = opendir((char*)pad.c_str());$/;"	l
dir	worker.cpp	/^        DIR* dir = opendir((char*)ix->path.c_str());$/;"	l
dirs	testWorker.cpp	/^    vector<pooldir_t> dirs = w.getNdirs(2); $/;"	l
doTask	worker.h	/^        int doTask(task_t * task);$/;"	p	class:Worker	access:public	signature:(task_t * task)
endl	testWorker.cpp	/^            cout << "TEST: task added: " << j << i << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error changing linktarget" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error copying testfile" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error creating dir" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error creating testfile" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error deleting testfile" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error linking testfile" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "error moving testfile" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "no" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "testdir created" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "testfile copied" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "testfile created" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "testfile deleted" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << "testfile moved" << endl;$/;"	l
endl	testWorker.cpp	/^        cout << buffer<< endl;$/;"	l
endl	testWorker.cpp	/^    cout << "Flex-structure: \/home\/jos\/tmp\/test1.txt" << endl;$/;"	l
endl	testWorker.cpp	/^    cout << "Pool-structure: \/home\/jos\/pool1\/home\/jos\/tmp\/test1.txt" << endl;$/;"	l
endl	testWorker.cpp	/^    cout << "TEST FUNCTIONS" << endl;$/;"	l
endl	testWorker.cpp	/^    cout << "TEST add task" << endl;$/;"	l
endl	testWorker.cpp	/^    cout << "Test copy\/rename\/delete files" << endl;$/;"	l
endl	testWorker.cpp	/^    cout << "the two most empty dirs are: " << endl;$/;"	l
endl	worker.cpp	/^            cout << "        <\/flexfile>" << endl;$/;"	l
endl	worker.cpp	/^            cout << "        <\/poolfile>" << endl;$/;"	l
endl	worker.cpp	/^            cout << "        <flexfile>" << endl;$/;"	l
endl	worker.cpp	/^            cout << "        <poolfile>" << endl;$/;"	l
endl	worker.cpp	/^        cout << "      <\/files>" << endl;$/;"	l
endl	worker.cpp	/^        cout << "      <files>" << endl;$/;"	l
endl	worker.cpp	/^        cout << "    <\/flexdir>" << endl;$/;"	l
endl	worker.cpp	/^        cout << "    <\/pooldir>" << endl;$/;"	l
endl	worker.cpp	/^        cout << entry << endl;$/;"	l
endl	worker.cpp	/^    cout << "  <\/flexdirs>\\n  <pooldirs>" << endl;$/;"	l
endl	worker.cpp	/^    cout << "  <\/pooldirs>\\n<\/fileStructure>" << endl;$/;"	l
endl	worker.cpp	/^    cout << "  <\/pooldirs>\\n<\/settings>" << endl;$/;"	l
endl	worker.cpp	/^    cout << "  <flexdirs>" << endl;$/;"	l
endl	worker.cpp	/^    cout << "<fileStructure>" << endl;$/;"	l
endl	worker.cpp	/^    cout << "<settings>" << endl;$/;"	l
entry	worker.cpp	/^                    struct dirent* entry;$/;"	l
entry	worker.cpp	/^            struct dirent* entry;$/;"	l
entry	worker.cpp	/^    log << entry << "\\n";$/;"	l
entry	worker.cpp	/^    string entry = getTime("%d-%m-%Y %H:%M:%S") + " > " + txt;$/;"	l
erase	worker.cpp	/^                key.erase(key.find_first_of("\\t "));$/;"	p	file:	signature:(key.find_first_of(Ó))
erase	worker.cpp	/^                temp.erase(temp.find('#'));$/;"	p	file:	signature:(temp.find(Ã))
erase	worker.cpp	/^            value.erase(value.find_last_not_of("\\t ") + 1);$/;"	p	file:	signature:(value.find_last_not_of(Ó) + 1)
event	watcher.cpp	/^            struct inotify_event * event = (struct inotify_event *) &buffer[i];$/;"	l
f	worker.cpp	/^                            poolfile_t f;$/;"	l
f	worker.cpp	/^                    flexfile_t f;$/;"	l
f	worker.cpp	/^                flexdir_t f;$/;"	l
f	worker.cpp	/^                pooldir_t f;$/;"	l
fb	worker.cpp	/^            long fb = buffer.f_bfree;$/;"	l
fd	testWorker.cpp	/^    flexdir_t fd;$/;"	l
fd	watcher.cpp	/^    int length, i = 0, n = 0, fd;$/;"	l
ff	testWorker.cpp	/^    flexfile_t ff;$/;"	l
file	testWorker.cpp	/^            string file = "touch " + t.from;$/;"	l
file	worker.cpp	/^    ifstream file;$/;"	l
fileTest	testWorker.cpp	/^void fileTest()$/;"	f	signature:()
fileTest	testWorker.cpp	/^void fileTest();$/;"	p	file:	signature:()
files	worker.cpp	/^    vector<poolfile_t> files;$/;"	l
files	worker.h	/^    vector<flexfile_t> files;$/;"	m	struct:flexdir_t	access:public
files	worker.h	/^    vector<poolfile_t> files;$/;"	m	struct:pooldir_t	access:public
flexdir_t	worker.h	/^struct flexdir_t$/;"	s
flexdir_t::copies	worker.h	/^    int copies;$/;"	m	struct:flexdir_t	access:public
flexdir_t::files	worker.h	/^    vector<flexfile_t> files;$/;"	m	struct:flexdir_t	access:public
flexdir_t::path	worker.h	/^    string path;$/;"	m	struct:flexdir_t	access:public
flexdir_t::watchdescriptor	worker.h	/^    int watchdescriptor;$/;"	m	struct:flexdir_t	access:public
flexdirs	worker.h	/^    vector<flexdir_t> flexdirs;$/;"	m	struct:settings_t	access:public
flexfile_t	worker.h	/^struct flexfile_t$/;"	s
flexfile_t::actualCopies	worker.h	/^    int actualCopies;$/;"	m	struct:flexfile_t	access:public
flexfile_t::name	worker.h	/^    string name;$/;"	m	struct:flexfile_t	access:public
flexfile_t::role	worker.h	/^    role_t role;$/;"	m	struct:flexfile_t	access:public
flexfile_t::x_path	worker.h	/^    string x_path;$/;"	m	struct:flexfile_t	access:public
freeMB	worker.h	/^    long freeMB;$/;"	m	struct:pooldir_t	access:public
from	worker.h	/^    string from;$/;"	m	struct:task_t	access:public
getFileExists	worker.h	/^        bool getFileExists(const char * path);$/;"	p	class:Worker	access:public	signature:(const char * path)
getFlexStructFromPath	worker.h	/^        int getFlexStructFromPath(flexdir_t * flexdir, flexfile_t * flexfile, string path);$/;"	p	class:Worker	access:public	signature:(flexdir_t * flexdir, flexfile_t * flexfile, string path)
getIsLink	worker.h	/^        bool getIsLink(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
getLinkTarget	worker.h	/^        string getLinkTarget(char * path);$/;"	p	class:Worker	access:public	signature:(char * path)
getLoadAverage	worker.cpp	/^double Worker::getLoadAverage()$/;"	f	class:Worker	signature:()
getLoadAverage	worker.h	/^        double getLoadAverage();$/;"	p	class:Worker	access:public	signature:()
getNdirs	worker.cpp	/^vector<pooldir_t> Worker::getNdirs(int n)$/;"	f	class:Worker	signature:(int n)
getNdirs	worker.h	/^        vector<pooldir_t> getNdirs(int n);$/;"	p	class:Worker	access:public	signature:(int n)
getPoolFiles	worker.cpp	/^vector<poolfile_t> Worker::getPoolFiles(flexfile_t * flexfile)$/;"	f	class:Worker	signature:(flexfile_t * flexfile)
getPoolFiles	worker.h	/^        vector<poolfile_t> getPoolFiles(flexfile_t * flexfile);$/;"	p	class:Worker	access:private	signature:(flexfile_t * flexfile)
getPoolSizes	worker.cpp	/^void Worker::getPoolSizes()$/;"	f	class:Worker	signature:()
getPoolSizes	worker.h	/^        void getPoolSizes();$/;"	p	class:Worker	access:private	signature:()
getPoolStructFromPath	worker.h	/^        int getPoolStructFromPath(pooldir_t * pooldir, poolfile_t * poolfile, string path);$/;"	p	class:Worker	access:public	signature:(pooldir_t * pooldir, poolfile_t * poolfile, string path)
getSettings	worker.cpp	/^settings_t * Worker::getSettings()$/;"	f	class:Worker	signature:()
getSettings	worker.h	/^        settings_t * getSettings();$/;"	p	class:Worker	access:public	signature:()
getTime	worker.cpp	/^string Worker::getTime(const char * format)$/;"	f	class:Worker	signature:(const char * format)
getTime	worker.h	/^        string getTime(const char * format);$/;"	p	class:Worker	access:public	signature:(const char * format)
i	testWorker.cpp	/^            ss << j << i;$/;"	l
i	watcher.cpp	/^    int length, i = 0, n = 0, fd;$/;"	l
i	worker.cpp	/^    vector<pooldir_t>::iterator i;$/;"	l
ip	worker.cpp	/^    vector<pooldir_t>::iterator ip;$/;"	l
ipf	worker.cpp	/^    vector<pooldir_t>::iterator ipf;$/;"	l
islink	testWorker.cpp	/^    string islink = "\/home\/jos\/tmp\/islink";$/;"	l
it	watcher.cpp	/^    vector<flexdir_t>::iterator it;$/;"	l
iter	testWorker.cpp	/^    vector<pooldir_t>::iterator iter;$/;"	l
iter	worker.cpp	/^    vector<pooldir_t>::iterator iter;$/;"	l
ix	worker.cpp	/^    vector<flexdir_t>::iterator ix;$/;"	l
ixf	worker.cpp	/^    vector<flexdir_t>::iterator ixf;$/;"	l
key	worker.cpp	/^            string key, value;$/;"	l
length	watcher.cpp	/^    int length, i = 0, n = 0, fd;$/;"	l
line	worker.cpp	/^        string line;$/;"	l
lineNo	worker.cpp	/^        size_t lineNo = 0;$/;"	l
linktst	testWorker.cpp	/^void linktst(string testlink)$/;"	f	signature:(string testlink)
linktst	testWorker.cpp	/^void linktst(string testlink);$/;"	p	file:	signature:(string testlink)
loadFileStructure	worker.cpp	/^void Worker::loadFileStructure()$/;"	f	class:Worker	signature:()
loadFileStructure	worker.h	/^        void loadFileStructure();$/;"	p	class:Worker	access:private	signature:()
loadFlexFiles	worker.cpp	/^void Worker::loadFlexFiles()$/;"	f	class:Worker	signature:()
loadFlexFiles	worker.h	/^        void loadFlexFiles();$/;"	p	class:Worker	access:private	signature:()
loadPoolFiles	worker.cpp	/^void Worker::loadPoolFiles()$/;"	f	class:Worker	signature:()
loadPoolFiles	worker.h	/^        void loadPoolFiles();$/;"	p	class:Worker	access:private	signature:()
loadSettings	worker.cpp	/^void Worker::loadSettings()$/;"	f	class:Worker	signature:()
loadSettings	worker.h	/^        void loadSettings();$/;"	p	class:Worker	access:private	signature:()
loadavg	worker.cpp	/^    double loadavg = -1;$/;"	l
loadavg	worker.cpp	/^    la >> loadavg;$/;"	l
log	worker.cpp	/^    fstream log;$/;"	l
logFile	worker.h	/^        string logFile;$/;"	m	class:Worker	access:private
main	main.cpp	/^int main()$/;"	f	signature:()
main	makefile	/^main = testWorker$/;"	m
main	testWorker.cpp	/^int main()$/;"	f	signature:()
maxLoadAverage	worker.h	/^    double maxLoadAverage;$/;"	m	struct:settings_t	access:public
maxLoadSleep	worker.h	/^    int maxLoadSleep;$/;"	m	struct:settings_t	access:public
maxWorkerThreads	worker.h	/^    int maxWorkerThreads;$/;"	m	struct:settings_t	access:public
mutex	testWorker.cpp	/^pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
n	watcher.cpp	/^    int length, i = 0, n = 0, fd;$/;"	l
naam	makefile	/^naam = flexdir$/;"	m
name	worker.h	/^    string name;$/;"	m	struct:flexfile_t	access:public
name	worker.h	/^    string name;$/;"	m	struct:poolfile_t	access:public
ndirtest	testWorker.cpp	/^void ndirtest()$/;"	f	signature:()
ndirtest	testWorker.cpp	/^void ndirtest();$/;"	p	file:	signature:()
next	watcher.cpp	/^            struct inotify_event * next = (struct inotify_event *) &buffer[n];$/;"	l
nothing	testWorker.cpp	/^    string nothing= "\/home\/jos\/tmp\/doesntexist";$/;"	l
open	worker.cpp	/^    file.open(SETTINGS);$/;"	p	file:	signature:(SETTINGS)
open	worker.cpp	/^    log.open(DEF_LOGFILE, fstream::in | fstream::out | fstream::app);$/;"	p	file:	signature:(DEF_LOGFILE, fstream::in | fstream::out | fstream::app)
p_path	worker.h	/^    string p_path;$/;"	m	struct:poolfile_t	access:public
pad	worker.cpp	/^            string pad = ip->path + "\/" + ix->path;$/;"	l
path	worker.h	/^    string path;$/;"	m	struct:flexdir_t	access:public
path	worker.h	/^    string path;$/;"	m	struct:pooldir_t	access:public
pd	testWorker.cpp	/^    pooldir_t pd;$/;"	l
pf	testWorker.cpp	/^    poolfile_t pf;$/;"	l
pf	worker.cpp	/^    vector<poolfile_t>::iterator pf;$/;"	l
pid	main.cpp	/^    pid_t pid, sid;$/;"	l
pit	worker.cpp	/^    vector<pooldir_t>::iterator pit;$/;"	l
pooldirSort	worker.cpp	/^bool pooldirSort(pooldir_t d1, pooldir_t d2)$/;"	f	signature:(pooldir_t d1, pooldir_t d2)
pooldirSort	worker.h	/^bool pooldirSort(pooldir_t d1, pooldir_t d2);$/;"	p	signature:(pooldir_t d1, pooldir_t d2)
pooldir_t	worker.h	/^struct pooldir_t$/;"	s
pooldir_t::files	worker.h	/^    vector<poolfile_t> files;$/;"	m	struct:pooldir_t	access:public
pooldir_t::freeMB	worker.h	/^    long freeMB;$/;"	m	struct:pooldir_t	access:public
pooldir_t::path	worker.h	/^    string path;$/;"	m	struct:pooldir_t	access:public
pooldir_t::sizeMB	worker.h	/^    long sizeMB;$/;"	m	struct:pooldir_t	access:public
pooldir_t::usedPerc	worker.h	/^    double usedPerc;$/;"	m	struct:pooldir_t	access:public
pooldirs	worker.h	/^    vector<pooldir_t> pooldirs;$/;"	m	struct:settings_t	access:public
poolfile_t	worker.h	/^struct poolfile_t$/;"	s
poolfile_t::name	worker.h	/^    string name;$/;"	m	struct:poolfile_t	access:public
poolfile_t::p_path	worker.h	/^    string p_path;$/;"	m	struct:poolfile_t	access:public
poolfile_t::role	worker.h	/^    role_t role;$/;"	m	struct:poolfile_t	access:public
poolfile_t::x_path	worker.h	/^    string x_path;$/;"	m	struct:poolfile_t	access:public
ppath	worker.cpp	/^    string ppath;$/;"	l
printFileStructure	worker.cpp	/^void Worker::printFileStructure()$/;"	f	class:Worker	signature:()
printFileStructure	worker.h	/^        void printFileStructure();$/;"	p	class:Worker	access:public	signature:()
printSettings	worker.cpp	/^void Worker::printSettings()$/;"	f	class:Worker	signature:()
printSettings	worker.h	/^        void printSettings();$/;"	p	class:Worker	access:public	signature:()
push_back	worker.cpp	/^                            ip->files.push_back(f);$/;"	p	file:	signature:(f)
push_back	worker.cpp	/^                    ix->files.push_back(f);$/;"	p	file:	signature:(f)
push_back	worker.cpp	/^                    settings.flexdirs.push_back(f);$/;"	p	file:	signature:(f)
push_back	worker.cpp	/^                    settings.pooldirs.push_back(f);$/;"	p	file:	signature:(f)
rawtime	worker.cpp	/^    time_t rawtime;$/;"	l
ret	worker.cpp	/^    string ret(buffer);$/;"	p	file:	signature:(buffer)
ret	worker.cpp	/^    vector<pooldir_t> ret;$/;"	l
retc	main.cpp	/^    int retw, retc;$/;"	l
retw	main.cpp	/^    int retw, retc;$/;"	l
retw	testWorker.cpp	/^    int retw;$/;"	l
role	worker.h	/^    role_t role;$/;"	m	struct:flexfile_t	access:public
role	worker.h	/^    role_t role;$/;"	m	struct:poolfile_t	access:public
role_t	worker.h	/^enum role_t { NONE, FLEXFILE, NEW, PRIMARY, SECONDARY, ORPHAN, COPIES };$/;"	g
s	testWorker.cpp	/^settings_t * s;$/;"	v
s	watcher.cpp	/^    settings_t * s = worker->getSettings();$/;"	l
sepPos	worker.cpp	/^            size_t sepPos = temp.find('=');$/;"	l
settings	worker.h	/^        settings_t settings;$/;"	m	class:Worker	access:private
settingsValidLine	worker.cpp	/^bool Worker::settingsValidLine(const string &line) const$/;"	f	class:Worker	signature:(const string &line) const
settingsValidLine	worker.h	/^        bool settingsValidLine(const string &line) const;$/;"	p	class:Worker	access:private	signature:(const string &line) const
settings_t	worker.h	/^struct settings_t $/;"	s
settings_t::flexdirs	worker.h	/^    vector<flexdir_t> flexdirs;$/;"	m	struct:settings_t	access:public
settings_t::maxLoadAverage	worker.h	/^    double maxLoadAverage;$/;"	m	struct:settings_t	access:public
settings_t::maxLoadSleep	worker.h	/^    int maxLoadSleep;$/;"	m	struct:settings_t	access:public
settings_t::maxWorkerThreads	worker.h	/^    int maxWorkerThreads;$/;"	m	struct:settings_t	access:public
settings_t::pooldirs	worker.h	/^    vector<pooldir_t> pooldirs;$/;"	m	struct:settings_t	access:public
settings_t::tasks	worker.h	/^    queue<task_t> tasks;$/;"	m	struct:settings_t	access:public
settings_t::verbose	worker.h	/^    bool verbose;$/;"	m	struct:settings_t	access:public
sid	main.cpp	/^    pid_t pid, sid;$/;"	l
size	worker.cpp	/^        str << settings.tasks.size();$/;"	p	file:	signature:()
sizeMB	worker.h	/^    long sizeMB;$/;"	m	struct:pooldir_t	access:public
ss	testWorker.cpp	/^            stringstream ss;$/;"	l
start	checker.cpp	/^void Checker::start()$/;"	f	class:Checker	signature:()
start	checker.h	/^        void start();$/;"	p	class:Checker	access:public	signature:()
start	main.cpp	/^    ch.start();$/;"	p	file:	signature:()
start	main.cpp	/^    wa.start();   $/;"	p	file:	signature:()
start	watcher.cpp	/^void Watcher::start()$/;"	f	class:Watcher	signature:()
start	watcher.h	/^        void start();$/;"	p	class:Watcher	access:public	signature:()
startDaemon	main.cpp	/^void startDaemon()$/;"	f	signature:()
startDaemon	main.cpp	/^void startDaemon();$/;"	p	file:	signature:()
startThreads	main.cpp	/^void startThreads()$/;"	f	signature:()
startThreads	main.cpp	/^void startThreads();$/;"	p	file:	signature:()
startThreads	testWorker.cpp	/^void startThreads()$/;"	f	signature:()
startThreads	testWorker.cpp	/^void startThreads();$/;"	p	file:	signature:()
startWorker	worker.h	/^        void startWorker(pthread_mutex_t * mutex, pthread_cond_t * condition);$/;"	p	class:Worker	access:public	signature:(pthread_mutex_t * mutex, pthread_cond_t * condition)
str	worker.cpp	/^                    istringstream str(value.substr(value.find_last_of(' ') + 1));$/;"	p	file:	signature:(value.substr(value.find_last_of(Ã) + 1))
str	worker.cpp	/^                istringstream str(value);$/;"	p	file:	signature:(value)
str	worker.cpp	/^        stringstream str;$/;"	l
symlinkTest	testWorker.cpp	/^void symlinkTest();$/;"	p	file:	signature:()
symlinkTest	testWorker.cpp	/^void symlinkTest(){$/;"	f	signature:()
t	testWorker.cpp	/^    task_t t;$/;"	l
taskID_t	worker.h	/^enum taskID_t { ADD, SYNC, DELETE, REMOVE, RENAME };$/;"	g
task_t	worker.h	/^struct task_t$/;"	s
task_t::ID	worker.h	/^    taskID_t ID;$/;"	m	struct:task_t	access:public
task_t::from	worker.h	/^    string from;$/;"	m	struct:task_t	access:public
task_t::to	worker.h	/^    string to;$/;"	m	struct:task_t	access:public
tasks	worker.h	/^    queue<task_t> tasks;$/;"	m	struct:settings_t	access:public
teller	worker.cpp	/^    int teller = 0;$/;"	l
temp	worker.cpp	/^            string temp = line;$/;"	l
temp	worker.cpp	/^    string temp = line;$/;"	l
testFunctions	testWorker.cpp	/^void testFunctions()$/;"	f	signature:()
testFunctions	testWorker.cpp	/^void testFunctions();$/;"	p	file:	signature:()
testTasks	testWorker.cpp	/^void testTasks()$/;"	f	signature:()
testTasks	testWorker.cpp	/^void testTasks();$/;"	p	file:	signature:()
testlink	testWorker.cpp	/^    cout <<testlink << ": ";$/;"	l
testlink	testWorker.cpp	/^    string testlink = "\/home\/jos\/tmp\/testlink";$/;"	l
timeinfo	worker.cpp	/^    struct tm * timeinfo;$/;"	l
to	worker.h	/^    string to;$/;"	m	struct:task_t	access:public
usedPerc	worker.h	/^    double usedPerc;$/;"	m	struct:pooldir_t	access:public
value	worker.cpp	/^            string key, value;$/;"	l
verbose	worker.h	/^    bool verbose;$/;"	m	struct:settings_t	access:public
w	main.cpp	/^Checker ch(&w);$/;"	v
w	main.cpp	/^Watcher wa(&w);$/;"	v
w	main.cpp	/^Worker w;$/;"	v
w	testWorker.cpp	/^    w.actionChangeLink((char*)"\/home\/jos\/tmp\/testlink", (char*)"\/home\/jos\/tmp\/copiedTest.txt");$/;"	p	file:	signature:(char*)Ó, (char*)Ó
w	testWorker.cpp	/^    w.actionCopyFile((char*)"\/home\/jos\/tmp\/movedTest.txt", (char*)"\/home\/jos\/tmp\/copiedTest.txt");$/;"	p	file:	signature:(char*)Ó, (char*)Ó
w	testWorker.cpp	/^    w.actionCreateLink((char*)"\/home\/jos\/tmp\/movedTest.txt", (char*)"\/home\/jos\/tmp\/testlink");$/;"	p	file:	signature:(char*)Ó, (char*)Ó
w	testWorker.cpp	/^    w.actionCreatedir((char*)"\/home\/jos\/pool2\/home\/jos\/tmp");$/;"	p	file:	signature:(char*)Ó
w	testWorker.cpp	/^    w.actionDeleteFile((char*)"\/home\/jos\/tmp\/movedTest.txt");$/;"	p	file:	signature:(char*)Ó
w	testWorker.cpp	/^    w.actionMoveFile((char*)"\/home\/jos\/tmp\/testcopy.txt", (char*)"\/home\/jos\/tmp\/movedTest.txt");$/;"	p	file:	signature:(char*)Ó, (char*)Ó
w1	watcher.cpp	/^    int w1,w2; \/\/TODO: use array of dirs from config file$/;"	l
w2	watcher.cpp	/^    int w1,w2; \/\/TODO: use array of dirs from config file$/;"	l
wThread	testWorker.cpp	/^void * wThread(void * id)$/;"	f	signature:(void * id)
wThread	testWorker.cpp	/^void * wThread(void * id);$/;"	p	file:	signature:(void * id)
watchdescriptor	worker.h	/^    int watchdescriptor;$/;"	m	struct:flexdir_t	access:public
watcherThread	main.cpp	/^void * watcherThread(void * id)$/;"	f	signature:(void * id)
watcherThread	main.cpp	/^void * watcherThread(void * id);$/;"	p	file:	signature:(void * id)
wo	testWorker.cpp	/^    Worker wo = w;$/;"	l
worker	checker.h	/^        Worker * worker;$/;"	m	class:Checker	access:private
worker	watcher.h	/^        Worker * worker;$/;"	m	class:Watcher	access:private
working	worker.h	/^        bool working;$/;"	m	class:Worker	access:private
writeLog	worker.cpp	/^void Worker::writeLog(string txt)$/;"	f	class:Worker	signature:(string txt)
writeLog	worker.h	/^        void writeLog(string txt);$/;"	p	class:Worker	access:public	signature:(string txt)
wt	main.cpp	/^    pthread_t wt, ct;$/;"	l
wt	testWorker.cpp	/^    pthread_t wt;$/;"	l
x_path	worker.h	/^    string x_path;$/;"	m	struct:flexfile_t	access:public
x_path	worker.h	/^    string x_path;$/;"	m	struct:poolfile_t	access:public
xf	worker.cpp	/^    vector<flexfile_t>::iterator xf;$/;"	l
~Checker	checker.cpp	/^Checker::~Checker()$/;"	f	class:Checker	signature:()
~Checker	checker.h	/^        ~Checker();$/;"	p	class:Checker	access:public	signature:()
~Watcher	watcher.cpp	/^Watcher::~Watcher()$/;"	f	class:Watcher	signature:()
~Watcher	watcher.h	/^        ~Watcher();$/;"	p	class:Watcher	access:public	signature:()
~Worker	worker.cpp	/^Worker::~Worker()$/;"	f	class:Worker	signature:()
~Worker	worker.h	/^        ~Worker();$/;"	p	class:Worker	access:public	signature:()
